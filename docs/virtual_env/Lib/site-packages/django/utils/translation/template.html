<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>template.py</title>
  <link rel="stylesheet" href="..\..\..\..\..\..\pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>template.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>

<span class="kn">from</span> <span class="nn">django.template.base</span> <span class="kn">import</span> <span class="n">TRANSLATOR_COMMENT_MARK</span><span class="p">,</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">TokenType</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">TranslatorCommentWarning</span><span class="p">,</span> <span class="n">trim_whitespace</span>

<span class="n">dot_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\S&#39;</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>Change every non-whitespace character to the given char.
Used in the templatize function.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">blankout</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">char</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">return</span> <span class="n">dot_re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>


<span class="n">context_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;^\s+.*context\s+((?:&quot;[^&quot;]*?&quot;)|(?:&#39;[^&#39;]*?&#39;))\s*&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">inline_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      <p>Match the trans 'some text' part</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;^\s*trans\s+((?:&quot;[^&quot;]*?&quot;)|(?:&#39;[^&#39;]*?&#39;))&quot;&quot;&quot;</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      <p>Match and ignore optional filters</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;(?:\s*\|\s*[^\s:]+(?::(?:[^\s&#39;&quot;:]+|(?:&quot;[^&quot;]*?&quot;)|(?:&#39;[^&#39;]*?&#39;)))?)*&quot;&quot;&quot;</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      <p>Match the optional context part</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;(\s+.*context\s+((?:&quot;[^&quot;]*?&quot;)|(?:&#39;[^&#39;]*?&#39;)))?\s*&quot;&quot;&quot;</span>
<span class="p">)</span>
<span class="n">block_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;^\s*blocktrans(\s+.*context\s+((?:&quot;[^&quot;]*?&quot;)|(?:&#39;[^&#39;]*?&#39;)))?(?:\s+|$)&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">endblock_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;^\s*endblocktrans$&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">plural_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;^\s*plural$&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">constant_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;_\(((?:&quot;.*?&quot;)|(?:&#39;.*?&#39;))\)&quot;&quot;&quot;</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <p>out = StringIO('')
message_context = None
intrans = False
inplural = False
trimmed = False
singular = []
plural = []
incomment = False
comment = []
lineno_comment_map = {}
comment_lineno_cache = None</p>
<h1>Adding the u prefix allows gettext to recognize the string (#26093).</h1>
<p>raw_prefix = 'u'</p>
<p>def join_tokens(tokens, trim=False):
    message = ''.join(tokens)
    if trim:
        message = trim_whitespace(message)
    return message</p>
<p>for t in Lexer(src).tokenize():
    if incomment:
        if t.token_type == TokenType.BLOCK and t.contents == 'endcomment':
            content = ''.join(comment)
            translators_comment_start = None
            for lineno, line in enumerate(content.splitlines(True)):
                if line.lstrip().startswith(TRANSLATOR_COMMENT_MARK):
                    translators_comment_start = lineno
            for lineno, line in enumerate(content.splitlines(True)):
                if translators_comment_start is not None and lineno &gt;= translators_comment_start:
                    out.write(' # %s' % line)
                else:
                    out.write(' #\n')
            incomment = False
            comment = []
        else:
            comment.append(t.contents)
    elif intrans:
        if t.token_type == TokenType.BLOCK:
            endbmatch = endblock_re.match(t.contents)
            pluralmatch = plural_re.match(t.contents)
            if endbmatch:
                if inplural:
                    if message_context:
                        out.write(' npgettext({p}{!r}, {p}{!r}, {p}{!r},count) '.format(
                            message_context,
                            join_tokens(singular, trimmed),
                            join_tokens(plural, trimmed),
                            p=raw_prefix,
                        ))
                    else:
                        out.write(' ngettext({p}{!r}, {p}{!r}, count) '.format(
                            join_tokens(singular, trimmed),
                            join_tokens(plural, trimmed),
                            p=raw_prefix,
                        ))
                    for part in singular:
                        out.write(blankout(part, 'S'))
                    for part in plural:
                        out.write(blankout(part, 'P'))
                else:
                    if message_context:
                        out.write(' pgettext({p}{!r}, {p}{!r}) '.format(
                            message_context,
                            join_tokens(singular, trimmed),
                            p=raw_prefix,
                        ))
                    else:
                        out.write(' gettext({p}{!r}) '.format(
                            join_tokens(singular, trimmed),
                            p=raw_prefix,
                        ))
                    for part in singular:
                        out.write(blankout(part, 'S'))
                message_context = None
                intrans = False
                inplural = False
                singular = []
                plural = []
            elif pluralmatch:
                inplural = True
            else:
                filemsg = ''
                if origin:
                    filemsg = 'file %s, ' % origin
                raise SyntaxError(
                    "Translation blocks must not include other block tags: "
                    "%s (%sline %d)" % (t.contents, filemsg, t.lineno)
                )
        elif t.token_type == TokenType.VAR:
            if inplural:
                plural.append('%%(%s)s' % t.contents)
            else:
                singular.append('%%(%s)s' % t.contents)
        elif t.token_type == TokenType.TEXT:
            contents = t.contents.replace('%', '%%')
            if inplural:
                plural.append(contents)
            else:
                singular.append(contents)
    else:
        # Handle comment tokens (<code>{# ... #}</code>) plus other constructs on
        # the same line:
        if comment_lineno_cache is not None:
            cur_lineno = t.lineno + t.contents.count('\n')
            if comment_lineno_cache == cur_lineno:
                if t.token_type != TokenType.COMMENT:
                    for c in lineno_comment_map[comment_lineno_cache]:
                        filemsg = ''
                        if origin:
                            filemsg = 'file %s, ' % origin
                        warn_msg = (
                            "The translator-targeted comment '%s' "
                            "(%sline %d) was ignored, because it wasn't "
                            "the last item on the line."
                        ) % (c, filemsg, comment_lineno_cache)
                        warnings.warn(warn_msg, TranslatorCommentWarning)
                    lineno_comment_map[comment_lineno_cache] = []
            else:
                out.write('# %s' % ' | '.join(lineno_comment_map[comment_lineno_cache]))
            comment_lineno_cache = None</p>
<pre><code>    if t.token_type == TokenType.BLOCK:
        imatch = inline_re.match(t.contents)
        bmatch = block_re.match(t.contents)
        cmatches = constant_re.findall(t.contents)
        if imatch:
            g = imatch.group(1)
            if g[0] == '"':
                g = g.strip('"')
            elif g[0] == "'":
                g = g.strip("'")
            g = g.replace('%', '%%')
            if imatch.group(2):
                # A context is provided
                context_match = context_re.match(imatch.group(2))
                message_context = context_match.group(1)
                if message_context[0] == '"':
                    message_context = message_context.strip('"')
                elif message_context[0] == "'":
                    message_context = message_context.strip("'")
                out.write(' pgettext({p}{!r}, {p}{!r}) '.format(
                    message_context, g, p=raw_prefix
                ))
                message_context = None
            else:
                out.write(' gettext({p}{!r}) '.format(g, p=raw_prefix))
        elif bmatch:
            for fmatch in constant_re.findall(t.contents):
                out.write(' _(%s) ' % fmatch)
            if bmatch.group(1):
                # A context is provided
                context_match = context_re.match(bmatch.group(1))
                message_context = context_match.group(1)
                if message_context[0] == '"':
                    message_context = message_context.strip('"')
                elif message_context[0] == "'":
                    message_context = message_context.strip("'")
            intrans = True
            inplural = False
            trimmed = 'trimmed' in t.split_contents()
            singular = []
            plural = []
        elif cmatches:
            for cmatch in cmatches:
                out.write(' _(%s) ' % cmatch)
        elif t.contents == 'comment':
            incomment = True
        else:
            out.write(blankout(t.contents, 'B'))
    elif t.token_type == TokenType.VAR:
        parts = t.contents.split('|')
        cmatch = constant_re.match(parts[0])
        if cmatch:
            out.write(' _(%s) ' % cmatch.group(1))
        for p in parts[1:]:
            if p.find(':_(') &gt;= 0:
                out.write(' %s ' % p.split(':', 1)[1])
            else:
                out.write(blankout(p, 'F'))
    elif t.token_type == TokenType.COMMENT:
        if t.contents.lstrip().startswith(TRANSLATOR_COMMENT_MARK):
            lineno_comment_map.setdefault(t.lineno, []).append(t.contents)
            comment_lineno_cache = t.lineno
    else:
        out.write(blankout(t.contents, 'X'))
</code></pre>
<p>return out.getvalue()</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">templatize</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Turn a Django template into something that is understood by xgettext. It</span>
<span class="s2">    does so by translating the Django translation tags into standard gettext</span>
<span class="s2">    function invocations.</span>

</pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
