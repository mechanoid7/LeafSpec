<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>storage.py</title>
  <link rel="stylesheet" href="..\..\..\..\..\..\pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>storage.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">posixpath</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">unquote</span><span class="p">,</span> <span class="n">urldefrag</span><span class="p">,</span> <span class="n">urlsplit</span><span class="p">,</span> <span class="n">urlunsplit</span>

<span class="kn">from</span> <span class="nn">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">django.contrib.staticfiles.utils</span> <span class="kn">import</span> <span class="n">check_settings</span><span class="p">,</span> <span class="n">matches_patterns</span>
<span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">InvalidCacheBackendError</span><span class="p">,</span> <span class="n">cache</span> <span class="k">as</span> <span class="n">default_cache</span><span class="p">,</span> <span class="n">caches</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">django.core.exceptions</span> <span class="kn">import</span> <span class="n">ImproperlyConfigured</span>
<span class="kn">from</span> <span class="nn">django.core.files.base</span> <span class="kn">import</span> <span class="n">ContentFile</span>
<span class="kn">from</span> <span class="nn">django.core.files.storage</span> <span class="kn">import</span> <span class="n">FileSystemStorage</span><span class="p">,</span> <span class="n">get_storage_class</span>
<span class="kn">from</span> <span class="nn">django.utils.deprecation</span> <span class="kn">import</span> <span class="n">RemovedInDjango31Warning</span>
<span class="kn">from</span> <span class="nn">django.utils.functional</span> <span class="kn">import</span> <span class="n">LazyObject</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>Standard file system storage for static files.</p>
<p>The defaults for <code>location</code> and <code>base_url</code> are
<code>STATIC_ROOT</code> and <code>STATIC_URL</code>.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">class</span> <span class="nc">StaticFilesStorage</span><span class="p">(</span><span class="n">FileSystemStorage</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">STATIC_ROOT</span>
        <span class="k">if</span> <span class="n">base_url</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_url</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">STATIC_URL</span>
        <span class="n">check_settings</span><span class="p">(</span><span class="n">base_url</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">base_url</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      <p>FileSystemStorage fallbacks to MEDIA_ROOT when location
is empty, so we restore the empty value.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">if</span> <span class="ow">not</span> <span class="n">location</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_location</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="kc">None</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImproperlyConfigured</span><span class="p">(</span><span class="s2">&quot;You&#39;re using the staticfiles app &quot;</span>
                                       <span class="s2">&quot;without having set the STATIC_ROOT &quot;</span>
                                       <span class="s2">&quot;setting to a filesystem path.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">class</span> <span class="nc">HashedFilesMixin</span><span class="p">:</span>
    <span class="n">default_template</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;url(&quot;</span><span class="si">%s</span><span class="s2">&quot;)&quot;&quot;&quot;</span>
    <span class="n">max_post_process_passes</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">patterns</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="s2">&quot;*.css&quot;</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">r</span><span class="sd">&quot;&quot;&quot;(url\([&#39;&quot;]{0,1}\s*(.*?)[&quot;&#39;]{0,1}\))&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;(@import\s*[&quot;&#39;]\s*(.*?)[&quot;&#39;])&quot;&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;@import url(&quot;</span><span class="si">%s</span><span class="s2">&quot;)&quot;&quot;&quot;</span><span class="p">),</span>
        <span class="p">)),</span>
    <span class="p">)</span>
    <span class="n">keep_intermediate_files</span> <span class="o">=</span> <span class="kc">True</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hashed_files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">extension</span><span class="p">,</span> <span class="n">patterns</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">pattern</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">pattern</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_template</span>
                <span class="n">compiled</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">extension</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">compiled</span><span class="p">,</span> <span class="n">template</span><span class="p">))</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      <p>if content is None:
    return None
md5 = hashlib.md5()
for chunk in content.chunks():
    md5.update(chunk)
return md5.hexdigest()[:12]</p>
<pre><code>def hashed_name(self, name, content=None, filename=None):
</code></pre>
<h1><code>filename</code> is the name of file to hash if <code>content</code> isn't given.</h1>
<h1><code>name</code> is the base name to construct the new hashed filename from.</h1>
<p>parsed_name = urlsplit(unquote(name))
clean_name = parsed_name.path.strip()
filename = (filename and urlsplit(unquote(filename)).path.strip()) or clean_name
opened = content is None
if opened:
    if not self.exists(filename):
        raise ValueError("The file '%s' could not be found with %r." % (filename, self))
    try:
        content = self.open(filename)
    except OSError:
        # Handle directory paths and fragments
        return name
try:
    file_hash = self.file_hash(clean_name, content)
finally:
    if opened:
        content.close()
path, filename = os.path.split(clean_name)
root, ext = os.path.splitext(filename)
if file_hash is not None:
    file_hash = ".%s" % file_hash
hashed_name = os.path.join(path, "%s%s%s" %
                           (root, file_hash, ext))
unparsed_name = list(parsed_name)
unparsed_name[2] = hashed_name</p>
<h1>Special casing for a @font-face hack, like url(myfont.eot?#iefix")</h1>
<h1>http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax</h1>
<p>if '?#' in name and not unparsed_name[3]:
    unparsed_name[2] += '?'
return urlunsplit(unparsed_name)</p>
<pre><code>def _url(self, hashed_name_func, name, force=False, hashed_files=None):
</code></pre>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">def</span> <span class="nf">file_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return a hash of the file with the given name and optional content.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">        Return the non-hashed URL in DEBUG mode.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">        Return the non-hashed URL in DEBUG mode.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">        Return the custom URL converter for the given file name.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">            Convert the matched URL to a normalized and hashed URL.</span>

<span class="s2">            This requires figuring out which files the matched URL resolves</span>
<span class="s2">            to and calling the url() method of the storage.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">        Post process the given dictionary of files (called from collectstatic).</span>

<span class="s2">        Processing is actually two separate operations:</span>

<span class="s2">        1. renaming files to include a hash of their content for cache-busting,</span>
<span class="s2">           and copying those files to the target storage.</span>
<span class="s2">        2. adjusting files which contain references to other files so they</span>
<span class="s2">           refer to the cache-busting filenames.</span>

<span class="s2">        If either of these are performed on a file, then that file is considered</span>
<span class="s2">        post-processed.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">    A small dict-like wrapper for a given cache backend instance.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">    A static file system storage backend which also saves</span>
<span class="s2">    hashed copies of the files it saves.</span>
<span class="s2">#DIVIDER</span>
<span class="s2">    A static file system storage backend which also saves</span>
<span class="s2">    hashed copies of the files it saves.</span>

</pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <p>if settings.DEBUG and not force:
    hashed_name, fragment = name, ''
else:
    clean_name, fragment = urldefrag(name)
    if urlsplit(clean_name).path.endswith('/'):  # don't hash paths
        hashed_name = name
    else:
        args = (clean_name,)
        if hashed_files is not None:
            args += (hashed_files,)
        hashed_name = hashed_name_func(*args)</p>
<p>final_url = super().url(hashed_name)</p>
<h1>Special casing for a @font-face hack, like url(myfont.eot?#iefix")</h1>
<h1>http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax</h1>
<p>query_fragment = '?#' in name  # [sic!]
if fragment or query_fragment:
    urlparts = list(urlsplit(final_url))
    if fragment and not urlparts[4]:
        urlparts[4] = fragment
    if query_fragment and not urlparts[3]:
        urlparts[2] += '?'
    final_url = urlunsplit(urlparts)</p>
<p>return unquote(final_url)</p>
<pre><code>def url(self, name, force=False):
</code></pre>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      <p>return self._url(self.stored_name, name, force)</p>
<pre><code>def url_converter(self, name, hashed_files, template=None):
</code></pre>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      <p>if template is None:
    template = self.default_template</p>
<p>def converter(matchobj):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      <p>matched, url = matchobj.groups()</p>
<h1>Ignore absolute/protocol-relative and data-uri URLs.</h1>
<p>if re.match(r'^[a-z]+:', url):
    return matched</p>
<h1>Ignore absolute URLs that don't point to a static file (dynamic</h1>
<h1>CSS / JS?). Note that STATIC_URL cannot be empty.</h1>
<p>if url.startswith('/') and not url.startswith(settings.STATIC_URL):
    return matched</p>
<h1>Strip off the fragment so a path-like fragment won't interfere.</h1>
<p>url_path, fragment = urldefrag(url)</p>
<p>if url_path.startswith('/'):
    # Otherwise the condition above would have returned prematurely.
    assert url_path.startswith(settings.STATIC_URL)
    target_name = url_path[len(settings.STATIC_URL):]
else:
    # We're using the posixpath module to mix paths and URLs conveniently.
    source_name = name if os.sep == '/' else name.replace(os.sep, '/')
    target_name = posixpath.join(posixpath.dirname(source_name), url_path)</p>
<h1>Determine the hashed name of the target file with the storage backend.</h1>
<p>hashed_url = self._url(
    self._stored_name, unquote(target_name),
    force=True, hashed_files=hashed_files,
)</p>
<p>transformed_url = '/'.join(url_path.split('/')[:-1] + hashed_url.split('/')[-1:])</p>
<h1>Restore the fragment that was stripped off earlier.</h1>
<p>if fragment:
    transformed_url += ('?#' if '?#' in url else '#') + fragment</p>
<h1>Return the hashed version to the file</h1>
<p>return template % unquote(transformed_url)</p>
<pre><code>    return converter

def post_process(self, paths, dry_run=False, **options):
</code></pre>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-12'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-12'>#</a>
      </div>
      <h1>don't even dare to process the files if we're in dry run mode</h1>
<p>if dry_run:
    return</p>
<h1>where to store the new paths</h1>
<p>hashed_files = {}</p>
<h1>build a list of adjustable files</h1>
<p>adjustable_paths = [
    path for path in paths
    if matches_patterns(path, self._patterns)
]</p>
<h1>Do a single pass first. Post-process all files once, then repeat for</h1>
<h1>adjustable files.</h1>
<p>for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):
    yield name, hashed_name, processed</p>
<p>paths = {path: paths[path] for path in adjustable_paths}</p>
<p>for i in range(self.max_post_process_passes):
    substitutions = False
    for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):
        yield name, hashed_name, processed
        substitutions = substitutions or subst</p>
<pre><code>if not substitutions:
    break
</code></pre>
<p>if substitutions:
    yield 'All', None, RuntimeError('Max post-process passes exceeded.')</p>
<h1>Store the processed paths</h1>
<p>self.hashed_files.update(hashed_files)</p>
<pre><code>def _post_process(self, paths, adjustable_paths, hashed_files):
</code></pre>
<h1>Sort the files by directory level</h1>
<p>def path_level(name):
    return len(name.split(os.sep))</p>
<p>for name in sorted(paths, key=path_level, reverse=True):
    substitutions = True
    # use the original, local file, not the copied-but-unprocessed
    # file, which might be somewhere far away, like S3
    storage, path = paths[name]
    with storage.open(path) as original_file:
        cleaned_name = self.clean_name(name)
        hash_key = self.hash_key(cleaned_name)</p>
<pre><code>    # generate the hash with the original content, even for
    # adjustable files.
    if hash_key not in hashed_files:
        hashed_name = self.hashed_name(name, original_file)
    else:
        hashed_name = hashed_files[hash_key]

    # then get the original's file content..
    if hasattr(original_file, 'seek'):
        original_file.seek(0)

    hashed_file_exists = self.exists(hashed_name)
    processed = False

    # ..to apply each replacement pattern to the content
    if name in adjustable_paths:
        old_hashed_name = hashed_name
        content = original_file.read().decode(settings.FILE_CHARSET)
        for extension, patterns in self._patterns.items():
            if matches_patterns(path, (extension,)):
                for pattern, template in patterns:
                    converter = self.url_converter(name, hashed_files, template)
                    try:
                        content = pattern.sub(converter, content)
                    except ValueError as exc:
                        yield name, None, exc, False
        if hashed_file_exists:
            self.delete(hashed_name)
        # then save the processed result
        content_file = ContentFile(content.encode())
        if self.keep_intermediate_files:
            # Save intermediate file for reference
            self._save(hashed_name, content_file)
        hashed_name = self.hashed_name(name, content_file)

        if self.exists(hashed_name):
            self.delete(hashed_name)

        saved_name = self._save(hashed_name, content_file)
        hashed_name = self.clean_name(saved_name)
        # If the file hash stayed the same, this file didn't change
        if old_hashed_name == hashed_name:
            substitutions = False
        processed = True

    if not processed:
        # or handle the case in which neither processing nor
        # a change to the original file happened
        if not hashed_file_exists:
            processed = True
            saved_name = self._save(hashed_name, original_file)
            hashed_name = self.clean_name(saved_name)

    # and then set the cache accordingly
    hashed_files[hash_key] = hashed_name

    yield name, hashed_name, processed, substitutions

def clean_name(self, name):
</code></pre>
<p>return name.replace('\', '/')</p>
<pre><code>def hash_key(self, name):
</code></pre>
<p>return name</p>
<pre><code>def _stored_name(self, name, hashed_files):
</code></pre>
<h1>Normalize the path to avoid multiple names for the same file like</h1>
<h1>../foo/bar.css and ../foo/../foo/bar.css which normalize to the same</h1>
<h1>path.</h1>
<p>name = posixpath.normpath(name)
cleaned_name = self.clean_name(name)
hash_key = self.hash_key(cleaned_name)
cache_name = hashed_files.get(hash_key)
if cache_name is None:
    cache_name = self.clean_name(self.hashed_name(name))
return cache_name</p>
<pre><code>def stored_name(self, name):
</code></pre>
<p>cleaned_name = self.clean_name(name)
hash_key = self.hash_key(cleaned_name)
cache_name = self.hashed_files.get(hash_key)
if cache_name:
    return cache_name</p>
<h1>No cached name found, recalculate it from the files.</h1>
<p>intermediate_name = name
for i in range(self.max_post_process_passes + 1):
    cache_name = self.clean_name(
        self.hashed_name(name, content=None, filename=intermediate_name)
    )
    if intermediate_name == cache_name:
        # Store the hashed name if there was a miss.
        self.hashed_files[hash_key] = cache_name
        return cache_name
    else:
        # Move on to the next intermediate file.
        intermediate_name = cache_name</p>
<h1>If the cache name can't be determined after the max number of passes,</h1>
<h1>the intermediate files on disk may be corrupt; avoid an infinite loop.</h1>
<p>raise ValueError("The name '%s' could not be hashed with %r." % (name, self))</p>
<p>class ManifestFilesMixin(HashedFilesMixin):
    manifest_version = '1.0'  # the manifest format standard
    manifest_name = 'staticfiles.json'
    manifest_strict = True
    keep_intermediate_files = False</p>
<pre><code>def __init__(self, *args, **kwargs):
</code></pre>
<p>super().<strong>init</strong>(<em>args, </em>*kwargs)
self.hashed_files = self.load_manifest()</p>
<pre><code>def read_manifest(self):
</code></pre>
<p>try:
    with self.open(self.manifest_name) as manifest:
        return manifest.read().decode()
except FileNotFoundError:
    return None</p>
<pre><code>def load_manifest(self):
</code></pre>
<p>content = self.read_manifest()
if content is None:
    return {}
try:
    stored = json.loads(content)
except json.JSONDecodeError:
    pass
else:
    version = stored.get('version')
    if version == '1.0':
        return stored.get('paths', {})
raise ValueError("Couldn't load manifest '%s' (version %s)" %
                 (self.manifest_name, self.manifest_version))</p>
<pre><code>def post_process(self, *args, **kwargs):
</code></pre>
<p>self.hashed_files = {}
yield from super().post_process(<em>args, </em>*kwargs)
if not kwargs.get('dry_run'):
    self.save_manifest()</p>
<pre><code>def save_manifest(self):
</code></pre>
<p>payload = {'paths': self.hashed_files, 'version': self.manifest_version}
if self.exists(self.manifest_name):
    self.delete(self.manifest_name)
contents = json.dumps(payload).encode()
self._save(self.manifest_name, ContentFile(contents))</p>
<pre><code>def stored_name(self, name):
</code></pre>
<p>parsed_name = urlsplit(unquote(name))
clean_name = parsed_name.path.strip()
hash_key = self.hash_key(clean_name)
cache_name = self.hashed_files.get(hash_key)
if cache_name is None:
    if self.manifest_strict:
        raise ValueError("Missing staticfiles manifest entry for '%s'" % clean_name)
    cache_name = self.clean_name(self.hashed_name(name))
unparsed_name = list(parsed_name)
unparsed_name[2] = cache_name</p>
<h1>Special casing for a @font-face hack, like url(myfont.eot?#iefix")</h1>
<h1>http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax</h1>
<p>if '?#' in name and not unparsed_name[3]:
    unparsed_name[2] += '?'
return urlunsplit(unparsed_name)</p>
<p>class _MappingCache:</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-13'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-13'>#</a>
      </div>
      <p>def <strong>init</strong>(self, cache):
    self.cache = cache</p>
<p>def <strong>setitem</strong>(self, key, value):
    self.cache.set(key, value)</p>
<p>def <strong>getitem</strong>(self, key):
    value = self.cache.get(key)
    if value is None:
        raise KeyError("Couldn't find a file name '%s'" % key)
    return value</p>
<p>def clear(self):
    self.cache.clear()</p>
<p>def update(self, data):
    self.cache.set_many(data)</p>
<p>def get(self, key, default=None):
    try:
        return self[key]
    except KeyError:
        return default</p>
<p>class CachedFilesMixin(HashedFilesMixin):
def <strong>init</strong>(self, <em>args, </em><em>kwargs):
    super().<strong>init</strong>(</em>args, **kwargs)
    try:
        self.hashed_files = _MappingCache(caches['staticfiles'])
    except InvalidCacheBackendError:
        # Use the default backend
        self.hashed_files = _MappingCache(default_cache)</p>
<p>def hash_key(self, name):
    key = hashlib.md5(self.clean_name(name).encode()).hexdigest()
    return 'staticfiles:%s' % key</p>
<p>class CachedStaticFilesStorage(CachedFilesMixin, StaticFilesStorage):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-14'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-14'>#</a>
      </div>
      <p>def <strong>init</strong>(self, <em>args, </em><em>kwargs):
    warnings.warn(
        'CachedStaticFilesStorage is deprecated in favor of '
        'ManifestStaticFilesStorage.',
        RemovedInDjango31Warning, stacklevel=2,
    )
    super().<strong>init</strong>(</em>args, **kwargs)</p>
<p>class ManifestStaticFilesStorage(ManifestFilesMixin, StaticFilesStorage):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-15'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-15'>#</a>
      </div>
      <p>pass</p>
<p>class ConfiguredStorage(LazyObject):
def _setup(self):
    self._wrapped = get_storage_class(settings.STATICFILES_STORAGE)()</p>
<p>staticfiles_storage = ConfiguredStorage()</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
